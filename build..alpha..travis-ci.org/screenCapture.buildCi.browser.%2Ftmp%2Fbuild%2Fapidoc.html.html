<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/websockets/ws">ws (v2.3.1)</a>
</h1>
<h4>Simple to use, blazing fast and thoroughly tested websocket client and server for Node.js</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.ws">module ws</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ws.ws">
            function <span class="apidocSignatureSpan"></span>ws
            <span class="apidocSignatureSpan">(String|String[])</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ws.Receiver">
            function <span class="apidocSignatureSpan">ws.</span>Receiver
            <span class="apidocSignatureSpan">(extensions, maxPayload, binaryType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ws.Sender">
            function <span class="apidocSignatureSpan">ws.</span>Sender
            <span class="apidocSignatureSpan">(socket, extensions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ws.Server">
            function <span class="apidocSignatureSpan">ws.</span>Server
            <span class="apidocSignatureSpan">(Boolean|Object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ws.WebSocket">
            function <span class="apidocSignatureSpan">ws.</span>WebSocket
            <span class="apidocSignatureSpan">(String|String[])</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">ws.</span>CLOSED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">ws.</span>CLOSING</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">ws.</span>CONNECTING</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">ws.</span>OPEN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ws.</span>BufferUtil</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ws.</span>Constants</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ws.</span>ErrorCodes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ws.</span>EventTarget</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ws.</span>Extensions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ws.</span>WebSocket.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ws.BufferUtil">module ws.BufferUtil</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ws.BufferUtil.concat">
            function <span class="apidocSignatureSpan">ws.BufferUtil.</span>concat
            <span class="apidocSignatureSpan">(list, totalLength)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ws.BufferUtil.mask">
            function <span class="apidocSignatureSpan">ws.BufferUtil.</span>mask
            <span class="apidocSignatureSpan">(source, mask, output, offset, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ws.BufferUtil.unmask">
            function <span class="apidocSignatureSpan">ws.BufferUtil.</span>unmask
            <span class="apidocSignatureSpan">(buffer, mask)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ws.Constants">module ws.Constants</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ws.Constants.NOOP">
            function <span class="apidocSignatureSpan">ws.Constants.</span>NOOP
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ws.Constants.</span>BINARY_TYPES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ws.Constants.</span>EMPTY_BUFFER</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">ws.Constants.</span>GUID</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ws.ErrorCodes">module ws.ErrorCodes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ws.ErrorCodes.isValidErrorCode">
            function <span class="apidocSignatureSpan">ws.ErrorCodes.</span>isValidErrorCode
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">ws.ErrorCodes.</span>1000</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">ws.ErrorCodes.</span>1001</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">ws.ErrorCodes.</span>1002</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">ws.ErrorCodes.</span>1003</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">ws.ErrorCodes.</span>1004</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">ws.ErrorCodes.</span>1005</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">ws.ErrorCodes.</span>1006</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">ws.ErrorCodes.</span>1007</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">ws.ErrorCodes.</span>1008</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">ws.ErrorCodes.</span>1009</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">ws.ErrorCodes.</span>1010</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">ws.ErrorCodes.</span>1011</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">ws.ErrorCodes.</span>1012</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">ws.ErrorCodes.</span>1013</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ws.EventTarget">module ws.EventTarget</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ws.EventTarget.addEventListener">
            function <span class="apidocSignatureSpan">ws.EventTarget.</span>addEventListener
            <span class="apidocSignatureSpan">(method, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ws.EventTarget.removeEventListener">
            function <span class="apidocSignatureSpan">ws.EventTarget.</span>removeEventListener
            <span class="apidocSignatureSpan">(method, listener)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ws.Extensions">module ws.Extensions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ws.Extensions.format">
            function <span class="apidocSignatureSpan">ws.Extensions.</span>format
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ws.Extensions.parse">
            function <span class="apidocSignatureSpan">ws.Extensions.</span>parse
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ws.WebSocket">module ws.WebSocket</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ws.WebSocket.WebSocket">
            function <span class="apidocSignatureSpan">ws.</span>WebSocket
            <span class="apidocSignatureSpan">(String|String[])</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ws.WebSocket.Receiver">
            function <span class="apidocSignatureSpan">ws.WebSocket.</span>Receiver
            <span class="apidocSignatureSpan">(extensions, maxPayload, binaryType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ws.WebSocket.Sender">
            function <span class="apidocSignatureSpan">ws.WebSocket.</span>Sender
            <span class="apidocSignatureSpan">(socket, extensions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ws.WebSocket.Server">
            function <span class="apidocSignatureSpan">ws.WebSocket.</span>Server
            <span class="apidocSignatureSpan">(Boolean|Object)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">ws.WebSocket.</span>CLOSED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">ws.WebSocket.</span>CLOSING</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">ws.WebSocket.</span>CONNECTING</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">ws.WebSocket.</span>OPEN</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ws.WebSocket.prototype">module ws.WebSocket.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ws.WebSocket.prototype.addEventListener">
            function <span class="apidocSignatureSpan">ws.WebSocket.prototype.</span>addEventListener
            <span class="apidocSignatureSpan">(method, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ws.WebSocket.prototype.removeEventListener">
            function <span class="apidocSignatureSpan">ws.WebSocket.prototype.</span>removeEventListener
            <span class="apidocSignatureSpan">(method, listener)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ws" id="apidoc.module.ws">module ws</a></h1>


    <h2>
        <a href="#apidoc.element.ws.ws" id="apidoc.element.ws.ws">
        function <span class="apidocSignatureSpan"></span>ws
        <span class="apidocSignatureSpan">(String|String[])</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WebSocket extends EventEmitter {
<span class="apidocCodeCommentSpan">  /**
   * Create a new `WebSocket`.
   *
   * @param {String} address The URL to which to connect
   * @param {(String|String[])} protocols The subprotocols
   * @param {Object} options Connection options
   */
</span>  constructor (address, protocols, options) {
    super();

    if (!protocols) {
      protocols = [];
    } else if (typeof protocols === 'string') {
      protocols = [protocols];
    } else if (!Array.isArray(protocols)) {
      options = protocols;
      protocols = [];
    }

    this.readyState = WebSocket.CONNECTING;
    this.bytesReceived = 0;
    this.extensions = {};
    this.protocol = '';

    this._binaryType = constants.BINARY_TYPES[0];
    this._finalize = this.finalize.bind(this);
    this._finalizeCalled = false;
    this._closeMessage = null;
    this._closeTimer = null;
    this._closeCode = null;
    this._receiver = null;
    this._sender = null;
    this._socket = null;
    this._ultron = null;

    if (Array.isArray(address)) {
      initAsServerClient.call(this, address[0], address[1], address[2], options);
    } else {
      initAsClient.call(this, address, protocols, options);
    }
  }

  get CONNECTING () { return WebSocket.CONNECTING; }
  get CLOSING () { return WebSocket.CLOSING; }
  get CLOSED () { return WebSocket.CLOSED; }
  get OPEN () { return WebSocket.OPEN; }

  /**
   * @type {Number}
   */
  get bufferedAmount () {
    var amount = 0;

    if (this._socket) {
      amount = this._socket.bufferSize + this._sender.bufferedBytes;
    }
    return amount;
  }

  /**
   * This deviates from the WHATWG interface since ws doesn't support the required
   * default "blob" type (instead we define a custom "nodebuffer" type).
   *
   * @type {String}
   */
  get binaryType () {
    return this._binaryType;
  }

  set binaryType (type) {
    if (constants.BINARY_TYPES.indexOf(type) &lt; 0) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver.binaryType = type;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @private
   */
  setSocket (socket, head) {
    socket.setTimeout(0);
    socket.setNoDelay();

    this._receiver = new Receiver(this.extensions, this.maxPayload, this.binaryType);
    this._sender = new Sender(socket, this.extensions);
    this._ultron = new Ultron(socket);
    this._socket = socket;

    // socket cleanup handlers
    this._ultron.on('close', this._finalize);
    this._ultron.on('error', this._finalize);
    this._ultron.on('end', this._finalize);

    // ensure that the head is added to the receiver
    if (head &amp;&amp; head.length &gt; 0) {
      socket.unshift(head);
      head = null;
    }

    // subsequent packets are pushed to the receiver
    this._ultron.on('data', (data) =&gt; {
      this.bytesReceived += data.length;
      this._receiver.add(data);
    });

    // receiver event handlers
    this._receiver.onmessage = (data, flags) =&gt; this.emit('message', data, flags);
    this._receiver.onping = (data, flags) =&gt; {
      this.pong(data, !this._isServer, true);
      this.emit('ping', data, flags);
    };
    this._receiver.onpong = (data, flags) =&gt; this.emit('pong', data, flags);
    this._receiver.onclose = (code, reason) =&gt; {
      this._closeMessage = reason;
      this._closeCode = code;
      this.close(code, reason);
    };
    this._receiver.onerror = (error, code) =&gt; {
      // close the connection when the receiver reports a HyBi error code
      this.close(code, '');
      this.emit('error', error);
    };

    // sender event handlers
    this._sender.onerror = (error) =&gt; {
      this.close(1002, '');
      this.emit('error', error);
    };

    this.readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Clean up and release internal resources.
   *
   * @param {(Boolean|Error)} Indicates whether or not an error occurred
   * @private
   */
  finali ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ws.Receiver" id="apidoc.element.ws.Receiver">
        function <span class="apidocSignatureSpan">ws.</span>Receiver
        <span class="apidocSignatureSpan">(extensions, maxPayload, binaryType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Receiver {
<span class="apidocCodeCommentSpan">  /**
   * Creates a Receiver instance.
   *
   * @param {Object} extensions An object containing the negotiated extensions
   * @param {Number} maxPayload The maximum allowed message length
   * @param {String} binaryType The type for binary data
   */
</span>  constructor (extensions, maxPayload, binaryType) {
    this.binaryType = binaryType || constants.BINARY_TYPES[0];
    this.extensions = extensions || {};
    this.maxPayload = maxPayload | 0;

    this.bufferedBytes = 0;
    this.buffers = [];

    this.compressed = false;
    this.payloadLength = 0;
    this.fragmented = 0;
    this.masked = false;
    this.fin = false;
    this.mask = null;
    this.opcode = 0;

    this.totalPayloadLength = 0;
    this.messageLength = 0;
    this.fragments = [];

    this.cleanupCallback = null;
    this.hadError = false;
    this.dead = false;
    this.loop = false;

    this.onmessage = null;
    this.onclose = null;
    this.onerror = null;
    this.onping = null;
    this.onpong = null;

    this.state = GET_INFO;
  }

  /**
   * Consumes bytes from the available buffered data.
   *
   * @param {Number} bytes The number of bytes to consume
   * @return {Buffer} Consumed bytes
   * @private
   */
  readBuffer (bytes) {
    var offset = 0;
    var dst;
    var l;

    this.bufferedBytes -= bytes;

    if (bytes === this.buffers[0].length) return this.buffers.shift();

    if (bytes &lt; this.buffers[0].length) {
      dst = this.buffers[0].slice(0, bytes);
      this.buffers[0] = this.buffers[0].slice(bytes);
      return dst;
    }

    dst = Buffer.allocUnsafe(bytes);

    while (bytes &gt; 0) {
      l = this.buffers[0].length;

      if (bytes &gt;= l) {
        this.buffers[0].copy(dst, offset);
        offset += l;
        this.buffers.shift();
      } else {
        this.buffers[0].copy(dst, offset, 0, bytes);
        this.buffers[0] = this.buffers[0].slice(bytes);
      }

      bytes -= l;
    }

    return dst;
  }

  /**
   * Checks if the number of buffered bytes is bigger or equal than `n` and
   * calls `cleanup` if necessary.
   *
   * @param {Number} n The number of bytes to check against
   * @return {Boolean} `true` if `bufferedBytes &gt;= n`, else `false`
   * @private
   */
  hasBufferedBytes (n) {
    if (this.bufferedBytes &gt;= n) return true;

    this.loop = false;
    if (this.dead) this.cleanup(this.cleanupCallback);
    return false;
  }

  /**
   * Adds new data to the parser.
   *
   * @public
   */
  add (data) {
    if (this.dead) return;

    this.bufferedBytes += data.length;
    this.buffers.push(data);
    this.startLoop();
  }

  /**
   * Starts the parsing loop.
   *
   * @private
   */
  startLoop () {
    this.loop = true;

    while (this.loop) {
      switch (this.state) {
        case GET_INFO:
          this.getInfo();
          break;
        case GET_PAYLOAD_LENGTH_16:
          this.getPayloadLength16();
          break;
        case GET_PAYLOAD_LENGTH_64:
          this.getPayloadLength64();
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          this.getData();
          break;
        default: // `INFLATING`
          this.loop = false;
      }
    }
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @private
   */
  getInfo () {
    if (!this.hasBufferedBytes(2)) return;

    const buf = this.readBuffer(2);

    if ((buf[0] &amp; 0x30) !== 0x00) {
      this.error(new Error('RSV2 and RSV3 must be clear'), 1002);
      return;
    }

    const compressed = (buf[0] &amp; 0x40) === 0x40;

    if (compressed &amp;&amp; !this.extensions[PerMessageDeflate.extensionName]) {
      this.error(new Error('RSV1 must be clear'), 1002);
      return;
    }

    this.fin = (buf[0] &amp; 0x80) === 0x80;
    this.opcode = buf[0] &amp; 0x0f;
    this.payloadLength = buf[1] &amp; 0x7f;

    if (this.opcode === 0x00) {
      if (compressed) {
        this.error(new Error('RSV1 must be clear'), 1002);
        return;
      }

      if (!this.fragmented) {
        this.error(new Error(`invalid opcode: ${this.opcode}`), 1002);
        return;
      } else { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ws.Sender" id="apidoc.element.ws.Sender">
        function <span class="apidocSignatureSpan">ws.</span>Sender
        <span class="apidocSignatureSpan">(socket, extensions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Sender {
<span class="apidocCodeCommentSpan">  /**
   * Creates a Sender instance.
   *
   * @param {net.Socket} socket The connection socket
   * @param {Object} extensions An object containing the negotiated extensions
   */
</span>  constructor (socket, extensions) {
    this.perMessageDeflate = (extensions || {})[PerMessageDeflate.extensionName];
    this._socket = socket;

    this.firstFragment = true;
    this.compress = false;

    this.bufferedBytes = 0;
    this.deflating = false;
    this.queue = [];

    this.onerror = null;
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {Buffer} data The data to frame
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} options.readOnly Specifies whether `data` can be modified
   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit
   * @return {Buffer[]} The framed data as a list of `Buffer` instances
   * @public
   */
  static frame (data, options) {
    const merge = data.length &lt; 1024 || (options.mask &amp;&amp; options.readOnly);
    var offset = options.mask ? 6 : 2;
    var payloadLength = data.length;

    if (data.length &gt;= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (data.length &gt; 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    if (payloadLength === 126) {
      target.writeUInt16BE(data.length, 2, true);
    } else if (payloadLength === 127) {
      target.writeUInt32BE(0, 2, true);
      target.writeUInt32BE(data.length, 6, true);
    }

    if (!options.mask) {
      target[1] = payloadLength;
      if (merge) {
        data.copy(target, offset);
        return [target];
      }

      return [target, data];
    }

    const mask = crypto.randomBytes(4);

    target[1] = payloadLength | 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (merge) {
      bufferUtil.mask(data, mask, target, offset, data.length);
      return [target];
    }

    bufferUtil.mask(data, mask, data, 0, data.length);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {(Number|undefined)} code The status code component of the body
   * @param {String} data The message component of the body
   * @param {Boolean} mask Specifies whether or not to mask the message
   * @param {Function} cb Callback
   * @public
   */
  close (code, data, mask, cb) {
    if (code !== undefined &amp;&amp; (typeof code !== 'number' || !ErrorCodes.isValidErrorCode(code))) {
      throw new Error('first argument must be a valid error code number');
    }

    const buf = Buffer.allocUnsafe(2 + (data ? Buffer.byteLength(data) : 0));

    buf.writeUInt16BE(code || 1000, 0, true);
    if (buf.length &gt; 2) buf.write(data, 2);

    if (this.deflating) {
      this.enqueue([this.doClose, buf, mask, cb]);
    } else {
      this.doClose(buf, mask, cb);
    }
  }

  /**
   * Frames and sends a close message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @private
   */
  doClose (data, mask, cb) {
    this.sendFrame(Sender.frame(data, {
      fin: true,
      rsv1: false,
      opcode: 0x08,
      mask,
      readOnly: false
    }), cb);
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @public
   */
  ping (data, mask) {
    var readOnly = true;

    if (!Buffer.isBuffer(data)) {
      if (data instanceof ArrayBuffer) {
        data = Buffer.from(data);
      } else if (ArrayBuffer.isV ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ws.Server" id="apidoc.element.ws.Server">
        function <span class="apidocSignatureSpan">ws.</span>Server
        <span class="apidocSignatureSpan">(Boolean|Object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WebSocketServer extends EventEmitter {
<span class="apidocCodeCommentSpan">  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {String} options.host The hostname where to bind the server
   * @param {Number} options.port The port where to bind the server
   * @param {http.Server} options.server A pre-created HTTP/S server to use
   * @param {Function} options.verifyClient An hook to reject connections
   * @param {Function} options.handleProtocols An hook to handle protocols
   * @param {String} options.path Accept only connections matching this path
   * @param {Boolean} options.noServer Enable no server mode
   * @param {Boolean} options.clientTracking Specifies whether or not to track clients
   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate
   * @param {Number} options.maxPayload The maximum allowed message size
   * @param {Function} callback A listener for the `listening` event
   */
</span>  constructor (options, callback) {
    super();

    options = Object.assign({
      maxPayload: 100 * 1024 * 1024,
      perMessageDeflate: true,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null
    }, options);

    if (options.port == null &amp;&amp; !options.server &amp;&amp; !options.noServer) {
      throw new TypeError('missing or invalid options');
    }

    if (options.port != null) {
      this._server = http.createServer((req, res) =&gt; {
        const body = http.STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.allowHalfOpen = false;
      this._server.listen(options.port, options.host, options.backlog, callback);
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      this._ultron = new Ultron(this._server);
      this._ultron.on('listening', () =&gt; this.emit('listening'));
      this._ultron.on('error', (err) =&gt; this.emit('error', err));
      this._ultron.on('upgrade', (req, socket, head) =&gt; {
        this.handleUpgrade(req, socket, head, (client) =&gt; {
          this.emit(`connection${req.url}`, client);
          this.emit('connection', client);
        });
      });
    }

    if (options.clientTracking) this.clients = new Set();
    this.options = options;
    this.path = options.path;
  }

  /**
   * Close the server.
   *
   * @param {Function} cb Callback
   * @public
   */
  close (cb) {
    //
    // Terminate all associated clients.
    //
    if (this.clients) {
      for (const client of this.clients) client.terminate();
    }

    const server = this._server;

    if (server) {
      this._ultron.destroy();
      this._ultron = this._server = null;

      //
      // Close the http server if it was internally created.
      //
      if (this.options.port != null) return server.close(cb);
    }

    if (cb) cb();
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle (req) {
    if (this.options.path &amp;&amp; url.parse(req.url).pathname !== this.options.path) {
      return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade (req, socket, head, cb) {
    socket.on('error', socketError);

    const version = +req.headers['sec-websocket-version'];

    if (
      req.method !== 'GET' || req.headers.upgrade.toLowerCase() !== 'websocket' ||
      !req.headers['sec-websocket-key'] || ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

To disable the extension you can set the `perMessageDeflate` option to `false`.
On the server:

```js
const WebSocket = require('ws');

const wss = new WebSocket.<span class="apidocCodeKeywordSpan">Server</span>({
  perMessageDeflate: false,
  port: 8080
});
```

On the client:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ws.WebSocket" id="apidoc.element.ws.WebSocket">
        function <span class="apidocSignatureSpan">ws.</span>WebSocket
        <span class="apidocSignatureSpan">(String|String[])</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WebSocket extends EventEmitter {
<span class="apidocCodeCommentSpan">  /**
   * Create a new `WebSocket`.
   *
   * @param {String} address The URL to which to connect
   * @param {(String|String[])} protocols The subprotocols
   * @param {Object} options Connection options
   */
</span>  constructor (address, protocols, options) {
    super();

    if (!protocols) {
      protocols = [];
    } else if (typeof protocols === 'string') {
      protocols = [protocols];
    } else if (!Array.isArray(protocols)) {
      options = protocols;
      protocols = [];
    }

    this.readyState = WebSocket.CONNECTING;
    this.bytesReceived = 0;
    this.extensions = {};
    this.protocol = '';

    this._binaryType = constants.BINARY_TYPES[0];
    this._finalize = this.finalize.bind(this);
    this._finalizeCalled = false;
    this._closeMessage = null;
    this._closeTimer = null;
    this._closeCode = null;
    this._receiver = null;
    this._sender = null;
    this._socket = null;
    this._ultron = null;

    if (Array.isArray(address)) {
      initAsServerClient.call(this, address[0], address[1], address[2], options);
    } else {
      initAsClient.call(this, address, protocols, options);
    }
  }

  get CONNECTING () { return WebSocket.CONNECTING; }
  get CLOSING () { return WebSocket.CLOSING; }
  get CLOSED () { return WebSocket.CLOSED; }
  get OPEN () { return WebSocket.OPEN; }

  /**
   * @type {Number}
   */
  get bufferedAmount () {
    var amount = 0;

    if (this._socket) {
      amount = this._socket.bufferSize + this._sender.bufferedBytes;
    }
    return amount;
  }

  /**
   * This deviates from the WHATWG interface since ws doesn't support the required
   * default "blob" type (instead we define a custom "nodebuffer" type).
   *
   * @type {String}
   */
  get binaryType () {
    return this._binaryType;
  }

  set binaryType (type) {
    if (constants.BINARY_TYPES.indexOf(type) &lt; 0) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver.binaryType = type;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @private
   */
  setSocket (socket, head) {
    socket.setTimeout(0);
    socket.setNoDelay();

    this._receiver = new Receiver(this.extensions, this.maxPayload, this.binaryType);
    this._sender = new Sender(socket, this.extensions);
    this._ultron = new Ultron(socket);
    this._socket = socket;

    // socket cleanup handlers
    this._ultron.on('close', this._finalize);
    this._ultron.on('error', this._finalize);
    this._ultron.on('end', this._finalize);

    // ensure that the head is added to the receiver
    if (head &amp;&amp; head.length &gt; 0) {
      socket.unshift(head);
      head = null;
    }

    // subsequent packets are pushed to the receiver
    this._ultron.on('data', (data) =&gt; {
      this.bytesReceived += data.length;
      this._receiver.add(data);
    });

    // receiver event handlers
    this._receiver.onmessage = (data, flags) =&gt; this.emit('message', data, flags);
    this._receiver.onping = (data, flags) =&gt; {
      this.pong(data, !this._isServer, true);
      this.emit('ping', data, flags);
    };
    this._receiver.onpong = (data, flags) =&gt; this.emit('pong', data, flags);
    this._receiver.onclose = (code, reason) =&gt; {
      this._closeMessage = reason;
      this._closeCode = code;
      this.close(code, reason);
    };
    this._receiver.onerror = (error, code) =&gt; {
      // close the connection when the receiver reports a HyBi error code
      this.close(code, '');
      this.emit('error', error);
    };

    // sender event handlers
    this._sender.onerror = (error) =&gt; {
      this.close(1002, '');
      this.emit('error', error);
    };

    this.readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Clean up and release internal resources.
   *
   * @param {(Boolean|Error)} Indicates whether or not an error occurred
   * @private
   */
  finali ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ws.BufferUtil" id="apidoc.module.ws.BufferUtil">module ws.BufferUtil</a></h1>


    <h2>
        <a href="#apidoc.element.ws.BufferUtil.concat" id="apidoc.element.ws.BufferUtil.concat">
        function <span class="apidocSignatureSpan">ws.BufferUtil.</span>concat
        <span class="apidocSignatureSpan">(list, totalLength)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(list, totalLength) =&gt; {
  const target = Buffer.allocUnsafe(totalLength);
  var offset = 0;

  for (var i = 0; i &lt; list.length; i++) {
    const buf = list[i];
    buf.copy(target, offset);
    offset += buf.length;
  }

  return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @public
 */
const format = (value) =&gt; {
  return Object.keys(value).map((token) =&gt; {
    var paramsList = value[token];
    if (!Array.isArray(paramsList)) paramsList = [paramsList];
    return paramsList.map((params) =&gt; {
      return [token].<span class="apidocCodeKeywordSpan">concat</span>(Object.keys(params).map((k) =&gt; {
        var p = params[k];
        if (!Array.isArray(p)) p = [p];
        return p.map((v) =&gt; v === true ? k : `${k}=${v}`).join('; ');
      })).join('; ');
    }).join(', ');
  }).join(', ');
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ws.BufferUtil.mask" id="apidoc.element.ws.BufferUtil.mask">
        function <span class="apidocSignatureSpan">ws.BufferUtil.</span>mask
        <span class="apidocSignatureSpan">(source, mask, output, offset, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(source, mask, output, offset, length) =&gt; {
  for (var i = 0; i &lt; length; i++) {
    output[offset + i] = source[i] ^ mask[i &amp; 3];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  target[1] = payloadLength | 0x80;
  target[offset - 4] = mask[0];
  target[offset - 3] = mask[1];
  target[offset - 2] = mask[2];
  target[offset - 1] = mask[3];

  if (merge) {
    bufferUtil.<span class="apidocCodeKeywordSpan">mask</span>(data, mask, target, offset, data.length);
    return [target];
  }

  bufferUtil.mask(data, mask, data, 0, data.length);
  return [target, data];
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ws.BufferUtil.unmask" id="apidoc.element.ws.BufferUtil.unmask">
        function <span class="apidocSignatureSpan">ws.BufferUtil.</span>unmask
        <span class="apidocSignatureSpan">(buffer, mask)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(buffer, mask) =&gt; {
  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
  const length = buffer.length;
  for (var i = 0; i &lt; length; i++) {
    buffer[i] ^= mask[i &amp; 3];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  getData () {
var data = constants.EMPTY_BUFFER;

if (this.payloadLength) {
  if (!this.hasBufferedBytes(this.payloadLength)) return;

  data = this.readBuffer(this.payloadLength);
  if (this.masked) bufferUtil.<span class="apidocCodeKeywordSpan">unmask</span>(data, this.mask);
}

if (this.opcode &gt; 0x07) {
  this.controlMessage(data);
} else if (this.compressed) {
  this.state = INFLATING;
  this.decompress(data);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ws.Constants" id="apidoc.module.ws.Constants">module ws.Constants</a></h1>


    <h2>
        <a href="#apidoc.element.ws.Constants.NOOP" id="apidoc.element.ws.Constants.NOOP">
        function <span class="apidocSignatureSpan">ws.Constants.</span>NOOP
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">() =&gt; {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ws.ErrorCodes" id="apidoc.module.ws.ErrorCodes">module ws.ErrorCodes</a></h1>


    <h2>
        <a href="#apidoc.element.ws.ErrorCodes.isValidErrorCode" id="apidoc.element.ws.ErrorCodes.isValidErrorCode">
        function <span class="apidocSignatureSpan">ws.ErrorCodes.</span>isValidErrorCode
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isValidErrorCode = function (code) {
  return (code &gt;= 1000 &amp;&amp; code &lt;= 1013 &amp;&amp; code !== 1004 &amp;&amp; code !== 1005 &amp;&amp; code !== 1006) ||
    (code &gt;= 3000 &amp;&amp; code &lt;= 4999);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.loop = false;
this.cleanup(this.cleanupCallback);
      } else if (data.length === 1) {
this.error(new Error('invalid payload length'), 1002);
      } else {
const code = data.readUInt16BE(0, true);

if (!ErrorCodes.<span class="apidocCodeKeywordSpan">isValidErrorCode</span>(code)) {
  this.error(new Error(`invalid status code: ${code}`), 1002);
  return;
}

const buf = data.slice(2);

if (!isValidUTF8(buf)) {
...</pre></li>
    </ul>






























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ws.EventTarget" id="apidoc.module.ws.EventTarget">module ws.EventTarget</a></h1>


    <h2>
        <a href="#apidoc.element.ws.EventTarget.addEventListener" id="apidoc.element.ws.EventTarget.addEventListener">
        function <span class="apidocSignatureSpan">ws.EventTarget.</span>addEventListener
        <span class="apidocSignatureSpan">(method, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addEventListener(method, listener) {
  if (typeof listener !== 'function') return;

  function onMessage (data, flags) {
    listener.call(this, new MessageEvent(data, !!flags.binary, this));
  }

  function onClose (code, message) {
    listener.call(this, new CloseEvent(code, message, this));
  }

  function onError (event) {
    event.type = 'error';
    event.target = this;
    listener.call(this, event);
  }

  function onOpen () {
    listener.call(this, new OpenEvent(this));
  }

  if (method === 'message') {
    onMessage._listener = listener;
    this.on(method, onMessage);
  } else if (method === 'close') {
    onClose._listener = listener;
    this.on(method, onClose);
  } else if (method === 'error') {
    onError._listener = listener;
    this.on(method, onError);
  } else if (method === 'open') {
    onOpen._listener = listener;
    this.on(method, onOpen);
  } else {
    this.on(method, listener);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      const listeners = this.listeners(method);
      for (var i = 0; i &lt; listeners.length; i++) {
        //
        // Remove only the listeners added via `addEventListener`.
        //
        if (listeners[i]._listener) this.removeListener(method, listeners[i]);
      }
      this.<span class="apidocCodeKeywordSpan">addEventListener</span>(method, listener);
    }
  });
});

WebSocket.prototype.addEventListener = EventTarget.addEventListener;
WebSocket.prototype.removeEventListener = EventTarget.removeEventListener;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ws.EventTarget.removeEventListener" id="apidoc.element.ws.EventTarget.removeEventListener">
        function <span class="apidocSignatureSpan">ws.EventTarget.</span>removeEventListener
        <span class="apidocSignatureSpan">(method, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeEventListener(method, listener) {
  const listeners = this.listeners(method);

  for (var i = 0; i &lt; listeners.length; i++) {
    if (listeners[i] === listener || listeners[i]._listener === listener) {
      this.removeListener(method, listeners[i]);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ws.Extensions" id="apidoc.module.ws.Extensions">module ws.Extensions</a></h1>


    <h2>
        <a href="#apidoc.element.ws.Extensions.format" id="apidoc.element.ws.Extensions.format">
        function <span class="apidocSignatureSpan">ws.Extensions.</span>format
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(value) =&gt; {
  return Object.keys(value).map((token) =&gt; {
    var paramsList = value[token];
    if (!Array.isArray(paramsList)) paramsList = [paramsList];
    return paramsList.map((params) =&gt; {
      return [token].concat(Object.keys(params).map((k) =&gt; {
        var p = params[k];
        if (!Array.isArray(p)) p = [p];
        return p.map((v) =&gt; v === true ? k : `${k}=${v}`).join('; ');
      })).join('; ');
    }).join(', ');
  }).join(', ');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    'Connection': 'Upgrade',
    'Upgrade': 'websocket'
  }
};

if (options.headers) Object.assign(requestOptions.headers, options.headers);
if (Object.keys(extensionsOffer).length) {
  requestOptions.headers['Sec-WebSocket-Extensions'] = Extensions.<span class="apidocCodeKeywordSpan">format</span>(extensionsOffer
);
}
if (options.protocol) {
  requestOptions.headers['Sec-WebSocket-Protocol'] = options.protocol;
}
if (options.origin) {
  if (options.protocolVersion &lt; 13) {
    requestOptions.headers['Sec-WebSocket-Origin'] = options.origin;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ws.Extensions.parse" id="apidoc.element.ws.Extensions.parse">
        function <span class="apidocSignatureSpan">ws.Extensions.</span>parse
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(value) =&gt; {
  value = value || '';

  const extensions = {};

  value.split(',').forEach((v) =&gt; {
    const params = v.split(';');
    const token = params.shift().trim();
    const paramsList = extensions[token] = extensions[token] || [];
    const parsedParams = {};

    params.forEach((param) =&gt; {
      const parts = param.trim().split('=');
      const key = parts[0];
      var value = parts[1];

      if (value === undefined) {
        value = true;
      } else {
        // unquote value
        if (value[0] === '"') {
          value = value.slice(1);
        }
        if (value[value.length - 1] === '"') {
          value = value.slice(0, value.length - 1);
        }
      }
      (parsedParams[key] = parsedParams[key] || []).push(value);
    });

    paramsList.push(parsedParams);
  });

  return extensions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
res.send({ msg: "hello" });
});

const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

wss.on('connection', function connection(ws) {
const location = url.<span class="apidocCodeKeywordSpan">parse</span>(ws.upgradeReq.url, true);
// You might use location.query.access_token to authenticate or share sessions
// or ws.upgradeReq.headers.cookie (see http://stackoverflow.com/a/16395220/151312)

ws.on('message', function incoming(message) {
  console.log('received: %s', message);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ws.WebSocket" id="apidoc.module.ws.WebSocket">module ws.WebSocket</a></h1>


    <h2>
        <a href="#apidoc.element.ws.WebSocket.WebSocket" id="apidoc.element.ws.WebSocket.WebSocket">
        function <span class="apidocSignatureSpan">ws.</span>WebSocket
        <span class="apidocSignatureSpan">(String|String[])</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WebSocket extends EventEmitter {
<span class="apidocCodeCommentSpan">  /**
   * Create a new `WebSocket`.
   *
   * @param {String} address The URL to which to connect
   * @param {(String|String[])} protocols The subprotocols
   * @param {Object} options Connection options
   */
</span>  constructor (address, protocols, options) {
    super();

    if (!protocols) {
      protocols = [];
    } else if (typeof protocols === 'string') {
      protocols = [protocols];
    } else if (!Array.isArray(protocols)) {
      options = protocols;
      protocols = [];
    }

    this.readyState = WebSocket.CONNECTING;
    this.bytesReceived = 0;
    this.extensions = {};
    this.protocol = '';

    this._binaryType = constants.BINARY_TYPES[0];
    this._finalize = this.finalize.bind(this);
    this._finalizeCalled = false;
    this._closeMessage = null;
    this._closeTimer = null;
    this._closeCode = null;
    this._receiver = null;
    this._sender = null;
    this._socket = null;
    this._ultron = null;

    if (Array.isArray(address)) {
      initAsServerClient.call(this, address[0], address[1], address[2], options);
    } else {
      initAsClient.call(this, address, protocols, options);
    }
  }

  get CONNECTING () { return WebSocket.CONNECTING; }
  get CLOSING () { return WebSocket.CLOSING; }
  get CLOSED () { return WebSocket.CLOSED; }
  get OPEN () { return WebSocket.OPEN; }

  /**
   * @type {Number}
   */
  get bufferedAmount () {
    var amount = 0;

    if (this._socket) {
      amount = this._socket.bufferSize + this._sender.bufferedBytes;
    }
    return amount;
  }

  /**
   * This deviates from the WHATWG interface since ws doesn't support the required
   * default "blob" type (instead we define a custom "nodebuffer" type).
   *
   * @type {String}
   */
  get binaryType () {
    return this._binaryType;
  }

  set binaryType (type) {
    if (constants.BINARY_TYPES.indexOf(type) &lt; 0) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver.binaryType = type;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @private
   */
  setSocket (socket, head) {
    socket.setTimeout(0);
    socket.setNoDelay();

    this._receiver = new Receiver(this.extensions, this.maxPayload, this.binaryType);
    this._sender = new Sender(socket, this.extensions);
    this._ultron = new Ultron(socket);
    this._socket = socket;

    // socket cleanup handlers
    this._ultron.on('close', this._finalize);
    this._ultron.on('error', this._finalize);
    this._ultron.on('end', this._finalize);

    // ensure that the head is added to the receiver
    if (head &amp;&amp; head.length &gt; 0) {
      socket.unshift(head);
      head = null;
    }

    // subsequent packets are pushed to the receiver
    this._ultron.on('data', (data) =&gt; {
      this.bytesReceived += data.length;
      this._receiver.add(data);
    });

    // receiver event handlers
    this._receiver.onmessage = (data, flags) =&gt; this.emit('message', data, flags);
    this._receiver.onping = (data, flags) =&gt; {
      this.pong(data, !this._isServer, true);
      this.emit('ping', data, flags);
    };
    this._receiver.onpong = (data, flags) =&gt; this.emit('pong', data, flags);
    this._receiver.onclose = (code, reason) =&gt; {
      this._closeMessage = reason;
      this._closeCode = code;
      this.close(code, reason);
    };
    this._receiver.onerror = (error, code) =&gt; {
      // close the connection when the receiver reports a HyBi error code
      this.close(code, '');
      this.emit('error', error);
    };

    // sender event handlers
    this._sender.onerror = (error) =&gt; {
      this.close(1002, '');
      this.emit('error', error);
    };

    this.readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Clean up and release internal resources.
   *
   * @param {(Boolean|Error)} Indicates whether or not an error occurred
   * @private
   */
  finali ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ws.WebSocket.Receiver" id="apidoc.element.ws.WebSocket.Receiver">
        function <span class="apidocSignatureSpan">ws.WebSocket.</span>Receiver
        <span class="apidocSignatureSpan">(extensions, maxPayload, binaryType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Receiver {
<span class="apidocCodeCommentSpan">  /**
   * Creates a Receiver instance.
   *
   * @param {Object} extensions An object containing the negotiated extensions
   * @param {Number} maxPayload The maximum allowed message length
   * @param {String} binaryType The type for binary data
   */
</span>  constructor (extensions, maxPayload, binaryType) {
    this.binaryType = binaryType || constants.BINARY_TYPES[0];
    this.extensions = extensions || {};
    this.maxPayload = maxPayload | 0;

    this.bufferedBytes = 0;
    this.buffers = [];

    this.compressed = false;
    this.payloadLength = 0;
    this.fragmented = 0;
    this.masked = false;
    this.fin = false;
    this.mask = null;
    this.opcode = 0;

    this.totalPayloadLength = 0;
    this.messageLength = 0;
    this.fragments = [];

    this.cleanupCallback = null;
    this.hadError = false;
    this.dead = false;
    this.loop = false;

    this.onmessage = null;
    this.onclose = null;
    this.onerror = null;
    this.onping = null;
    this.onpong = null;

    this.state = GET_INFO;
  }

  /**
   * Consumes bytes from the available buffered data.
   *
   * @param {Number} bytes The number of bytes to consume
   * @return {Buffer} Consumed bytes
   * @private
   */
  readBuffer (bytes) {
    var offset = 0;
    var dst;
    var l;

    this.bufferedBytes -= bytes;

    if (bytes === this.buffers[0].length) return this.buffers.shift();

    if (bytes &lt; this.buffers[0].length) {
      dst = this.buffers[0].slice(0, bytes);
      this.buffers[0] = this.buffers[0].slice(bytes);
      return dst;
    }

    dst = Buffer.allocUnsafe(bytes);

    while (bytes &gt; 0) {
      l = this.buffers[0].length;

      if (bytes &gt;= l) {
        this.buffers[0].copy(dst, offset);
        offset += l;
        this.buffers.shift();
      } else {
        this.buffers[0].copy(dst, offset, 0, bytes);
        this.buffers[0] = this.buffers[0].slice(bytes);
      }

      bytes -= l;
    }

    return dst;
  }

  /**
   * Checks if the number of buffered bytes is bigger or equal than `n` and
   * calls `cleanup` if necessary.
   *
   * @param {Number} n The number of bytes to check against
   * @return {Boolean} `true` if `bufferedBytes &gt;= n`, else `false`
   * @private
   */
  hasBufferedBytes (n) {
    if (this.bufferedBytes &gt;= n) return true;

    this.loop = false;
    if (this.dead) this.cleanup(this.cleanupCallback);
    return false;
  }

  /**
   * Adds new data to the parser.
   *
   * @public
   */
  add (data) {
    if (this.dead) return;

    this.bufferedBytes += data.length;
    this.buffers.push(data);
    this.startLoop();
  }

  /**
   * Starts the parsing loop.
   *
   * @private
   */
  startLoop () {
    this.loop = true;

    while (this.loop) {
      switch (this.state) {
        case GET_INFO:
          this.getInfo();
          break;
        case GET_PAYLOAD_LENGTH_16:
          this.getPayloadLength16();
          break;
        case GET_PAYLOAD_LENGTH_64:
          this.getPayloadLength64();
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          this.getData();
          break;
        default: // `INFLATING`
          this.loop = false;
      }
    }
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @private
   */
  getInfo () {
    if (!this.hasBufferedBytes(2)) return;

    const buf = this.readBuffer(2);

    if ((buf[0] &amp; 0x30) !== 0x00) {
      this.error(new Error('RSV2 and RSV3 must be clear'), 1002);
      return;
    }

    const compressed = (buf[0] &amp; 0x40) === 0x40;

    if (compressed &amp;&amp; !this.extensions[PerMessageDeflate.extensionName]) {
      this.error(new Error('RSV1 must be clear'), 1002);
      return;
    }

    this.fin = (buf[0] &amp; 0x80) === 0x80;
    this.opcode = buf[0] &amp; 0x0f;
    this.payloadLength = buf[1] &amp; 0x7f;

    if (this.opcode === 0x00) {
      if (compressed) {
        this.error(new Error('RSV1 must be clear'), 1002);
        return;
      }

      if (!this.fragmented) {
        this.error(new Error(`invalid opcode: ${this.opcode}`), 1002);
        return;
      } else { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ws.WebSocket.Sender" id="apidoc.element.ws.WebSocket.Sender">
        function <span class="apidocSignatureSpan">ws.WebSocket.</span>Sender
        <span class="apidocSignatureSpan">(socket, extensions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Sender {
<span class="apidocCodeCommentSpan">  /**
   * Creates a Sender instance.
   *
   * @param {net.Socket} socket The connection socket
   * @param {Object} extensions An object containing the negotiated extensions
   */
</span>  constructor (socket, extensions) {
    this.perMessageDeflate = (extensions || {})[PerMessageDeflate.extensionName];
    this._socket = socket;

    this.firstFragment = true;
    this.compress = false;

    this.bufferedBytes = 0;
    this.deflating = false;
    this.queue = [];

    this.onerror = null;
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {Buffer} data The data to frame
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} options.readOnly Specifies whether `data` can be modified
   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit
   * @param {Boolean} options.mask Specifies whether or not to mask `data`
   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit
   * @return {Buffer[]} The framed data as a list of `Buffer` instances
   * @public
   */
  static frame (data, options) {
    const merge = data.length &lt; 1024 || (options.mask &amp;&amp; options.readOnly);
    var offset = options.mask ? 6 : 2;
    var payloadLength = data.length;

    if (data.length &gt;= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (data.length &gt; 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    if (payloadLength === 126) {
      target.writeUInt16BE(data.length, 2, true);
    } else if (payloadLength === 127) {
      target.writeUInt32BE(0, 2, true);
      target.writeUInt32BE(data.length, 6, true);
    }

    if (!options.mask) {
      target[1] = payloadLength;
      if (merge) {
        data.copy(target, offset);
        return [target];
      }

      return [target, data];
    }

    const mask = crypto.randomBytes(4);

    target[1] = payloadLength | 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (merge) {
      bufferUtil.mask(data, mask, target, offset, data.length);
      return [target];
    }

    bufferUtil.mask(data, mask, data, 0, data.length);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {(Number|undefined)} code The status code component of the body
   * @param {String} data The message component of the body
   * @param {Boolean} mask Specifies whether or not to mask the message
   * @param {Function} cb Callback
   * @public
   */
  close (code, data, mask, cb) {
    if (code !== undefined &amp;&amp; (typeof code !== 'number' || !ErrorCodes.isValidErrorCode(code))) {
      throw new Error('first argument must be a valid error code number');
    }

    const buf = Buffer.allocUnsafe(2 + (data ? Buffer.byteLength(data) : 0));

    buf.writeUInt16BE(code || 1000, 0, true);
    if (buf.length &gt; 2) buf.write(data, 2);

    if (this.deflating) {
      this.enqueue([this.doClose, buf, mask, cb]);
    } else {
      this.doClose(buf, mask, cb);
    }
  }

  /**
   * Frames and sends a close message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @param {Function} cb Callback
   * @private
   */
  doClose (data, mask, cb) {
    this.sendFrame(Sender.frame(data, {
      fin: true,
      rsv1: false,
      opcode: 0x08,
      mask,
      readOnly: false
    }), cb);
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} mask Specifies whether or not to mask `data`
   * @public
   */
  ping (data, mask) {
    var readOnly = true;

    if (!Buffer.isBuffer(data)) {
      if (data instanceof ArrayBuffer) {
        data = Buffer.from(data);
      } else if (ArrayBuffer.isV ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ws.WebSocket.Server" id="apidoc.element.ws.WebSocket.Server">
        function <span class="apidocSignatureSpan">ws.WebSocket.</span>Server
        <span class="apidocSignatureSpan">(Boolean|Object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WebSocketServer extends EventEmitter {
<span class="apidocCodeCommentSpan">  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {String} options.host The hostname where to bind the server
   * @param {Number} options.port The port where to bind the server
   * @param {http.Server} options.server A pre-created HTTP/S server to use
   * @param {Function} options.verifyClient An hook to reject connections
   * @param {Function} options.handleProtocols An hook to handle protocols
   * @param {String} options.path Accept only connections matching this path
   * @param {Boolean} options.noServer Enable no server mode
   * @param {Boolean} options.clientTracking Specifies whether or not to track clients
   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate
   * @param {Number} options.maxPayload The maximum allowed message size
   * @param {Function} callback A listener for the `listening` event
   */
</span>  constructor (options, callback) {
    super();

    options = Object.assign({
      maxPayload: 100 * 1024 * 1024,
      perMessageDeflate: true,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null
    }, options);

    if (options.port == null &amp;&amp; !options.server &amp;&amp; !options.noServer) {
      throw new TypeError('missing or invalid options');
    }

    if (options.port != null) {
      this._server = http.createServer((req, res) =&gt; {
        const body = http.STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.allowHalfOpen = false;
      this._server.listen(options.port, options.host, options.backlog, callback);
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      this._ultron = new Ultron(this._server);
      this._ultron.on('listening', () =&gt; this.emit('listening'));
      this._ultron.on('error', (err) =&gt; this.emit('error', err));
      this._ultron.on('upgrade', (req, socket, head) =&gt; {
        this.handleUpgrade(req, socket, head, (client) =&gt; {
          this.emit(`connection${req.url}`, client);
          this.emit('connection', client);
        });
      });
    }

    if (options.clientTracking) this.clients = new Set();
    this.options = options;
    this.path = options.path;
  }

  /**
   * Close the server.
   *
   * @param {Function} cb Callback
   * @public
   */
  close (cb) {
    //
    // Terminate all associated clients.
    //
    if (this.clients) {
      for (const client of this.clients) client.terminate();
    }

    const server = this._server;

    if (server) {
      this._ultron.destroy();
      this._ultron = this._server = null;

      //
      // Close the http server if it was internally created.
      //
      if (this.options.port != null) return server.close(cb);
    }

    if (cb) cb();
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle (req) {
    if (this.options.path &amp;&amp; url.parse(req.url).pathname !== this.options.path) {
      return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade (req, socket, head, cb) {
    socket.on('error', socketError);

    const version = +req.headers['sec-websocket-version'];

    if (
      req.method !== 'GET' || req.headers.upgrade.toLowerCase() !== 'websocket' ||
      !req.headers['sec-websocket-key'] || ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

To disable the extension you can set the `perMessageDeflate` option to `false`.
On the server:

```js
const WebSocket = require('ws');

const wss = new WebSocket.<span class="apidocCodeKeywordSpan">Server</span>({
  perMessageDeflate: false,
  port: 8080
});
```

On the client:
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ws.WebSocket.prototype" id="apidoc.module.ws.WebSocket.prototype">module ws.WebSocket.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ws.WebSocket.prototype.addEventListener" id="apidoc.element.ws.WebSocket.prototype.addEventListener">
        function <span class="apidocSignatureSpan">ws.WebSocket.prototype.</span>addEventListener
        <span class="apidocSignatureSpan">(method, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addEventListener(method, listener) {
  if (typeof listener !== 'function') return;

  function onMessage (data, flags) {
    listener.call(this, new MessageEvent(data, !!flags.binary, this));
  }

  function onClose (code, message) {
    listener.call(this, new CloseEvent(code, message, this));
  }

  function onError (event) {
    event.type = 'error';
    event.target = this;
    listener.call(this, event);
  }

  function onOpen () {
    listener.call(this, new OpenEvent(this));
  }

  if (method === 'message') {
    onMessage._listener = listener;
    this.on(method, onMessage);
  } else if (method === 'close') {
    onClose._listener = listener;
    this.on(method, onClose);
  } else if (method === 'error') {
    onError._listener = listener;
    this.on(method, onError);
  } else if (method === 'open') {
    onOpen._listener = listener;
    this.on(method, onOpen);
  } else {
    this.on(method, listener);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      const listeners = this.listeners(method);
      for (var i = 0; i &lt; listeners.length; i++) {
        //
        // Remove only the listeners added via `addEventListener`.
        //
        if (listeners[i]._listener) this.removeListener(method, listeners[i]);
      }
      this.<span class="apidocCodeKeywordSpan">addEventListener</span>(method, listener);
    }
  });
});

WebSocket.prototype.addEventListener = EventTarget.addEventListener;
WebSocket.prototype.removeEventListener = EventTarget.removeEventListener;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ws.WebSocket.prototype.removeEventListener" id="apidoc.element.ws.WebSocket.prototype.removeEventListener">
        function <span class="apidocSignatureSpan">ws.WebSocket.prototype.</span>removeEventListener
        <span class="apidocSignatureSpan">(method, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeEventListener(method, listener) {
  const listeners = this.listeners(method);

  for (var i = 0; i &lt; listeners.length; i++) {
    if (listeners[i] === listener || listeners[i]._listener === listener) {
      this.removeListener(method, listeners[i]);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>